<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#ffffff">
<link rel="manifest" href="manifest.json">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<title>Daily Planner</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --primary: #4F46E5;
    --primary-soft: #DDD6FE;
    --primary-hover: #4338CA;
    --bg: #F1F3F8;
    --card: #FFFFFF;
    --text: #0F172A;
    --text-secondary: #475569;
    --text-tertiary: #94A3B8;
    --border: #E2E8F0;
    --border-strong: #CBD5E1;
    --success: #059669;
    --success-soft: #A7F3D0;
    --danger: #DC2626;
    --danger-soft: #FECACA;
    --office: #D97706;
    --office-soft: #FDE68A;
    --office-text: #78350F;
    --remote: #0891B2;
    --remote-soft: #A5F3FC;
    --remote-text: #164E63;
    --weekend-soft: #DDD6FE;
    --weekend-text: #5B21B6;
    --shadow-xs: 0 1px 2px rgba(0,0,0,0.06);
    --shadow-sm: 0 1px 3px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.06);
    --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.06);
    --shadow-lg: 0 10px 25px -3px rgba(0,0,0,0.15), 0 4px 6px -4px rgba(0,0,0,0.08);
    --shadow-fab: 0 8px 24px rgba(79,70,229,0.4);
    --radius: 16px;
    --radius-md: 12px;
    --radius-sm: 10px;
    --radius-xs: 8px;
  }

  html { font-size: 16px; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overscroll-behavior: none;
    padding-bottom: 120px;
    line-height: 1.5;
  }

  /* ===== HEADER ===== */
  .header {
    position: sticky; top: 0; z-index: 100;
    background: #FFFFFF;
    border-bottom: 2px solid var(--border);
    padding: 16px 20px 14px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
  }

  .header-top {
    display: flex; align-items: center; justify-content: space-between;
    gap: 8px;
  }

  .nav-btn {
    width: 40px; height: 40px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: none;
    border-radius: 50%; cursor: pointer;
    color: var(--text-secondary);
    transition: all 0.15s ease;
    -webkit-tap-highlight-color: transparent;
    flex-shrink: 0;
  }
  .nav-btn svg { width: 20px; height: 20px; }
  .nav-btn:active { background: var(--border); transform: scale(0.92); }

  .header-center {
    text-align: center; flex: 1; min-width: 0;
  }

  .date-display {
    display: flex; flex-direction: column; align-items: center; gap: 6px;
  }

  .date-weekday {
    font-size: 13px; font-weight: 600;
    color: var(--primary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .date-main {
    font-size: 20px; font-weight: 700;
    color: var(--text);
    letter-spacing: -0.4px;
  }

  .header-meta {
    display: flex; align-items: center; justify-content: center; gap: 8px;
    margin-top: 2px;
  }

  .day-badge {
    display: inline-flex; align-items: center; gap: 5px;
    font-size: 12px; font-weight: 700;
    padding: 4px 12px; border-radius: 20px;
    letter-spacing: 0.2px;
  }
  .day-badge.office { background: var(--office-soft); color: var(--office-text); border: 1.5px solid var(--office); }
  .day-badge.remote { background: var(--remote-soft); color: var(--remote-text); border: 1.5px solid var(--remote); }
  .day-badge.weekend { background: var(--weekend-soft); color: var(--weekend-text); border: 1.5px solid #8B5CF6; }

  .today-btn {
    font-size: 12px; font-weight: 600;
    color: var(--primary); background: var(--primary-soft);
    border: none; border-radius: 20px;
    padding: 4px 12px; cursor: pointer;
    display: none;
    transition: all 0.15s ease;
  }
  .today-btn.visible { display: inline-flex; }
  .today-btn:active { background: var(--primary); color: white; }

  /* ===== TIMELINE ===== */
  .timeline {
    padding: 4px 16px 0;
  }

  .hour-group {
    position: relative;
  }

  .time-block {
    display: flex; gap: 12px;
    padding: 0;
    min-height: 44px;
    position: relative;
    transition: all 0.2s ease;
  }

  .time-block.empty {
    min-height: 24px;
  }

  .time-block.current-slot {
    z-index: 2;
  }

  .time-gutter {
    width: 54px; flex-shrink: 0;
    padding-top: 10px;
    position: relative;
  }

  .time-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-secondary);
    text-align: right;
    padding-right: 12px;
    line-height: 1;
    font-variant-numeric: tabular-nums;
  }

  .time-block.on-hour .time-label {
    font-weight: 700;
    color: var(--text);
    font-size: 12px;
  }

  .time-block.current-slot .time-label {
    color: var(--primary);
    font-weight: 700;
  }

  .time-content {
    flex: 1;
    padding: 4px 0;
    min-height: inherit;
    display: flex; flex-direction: column; gap: 6px;
    border-top: 1px solid var(--border-strong);
    position: relative;
  }

  .time-block.on-hour .time-content {
    border-top: 2px solid var(--border-strong);
  }

  .time-block.current-slot .time-content {
    border-top-color: var(--primary);
    border-top-width: 2px;
  }

  .time-block.current-slot .time-content::before {
    content: '';
    position: absolute;
    left: -6px; top: -5px;
    width: 8px; height: 8px;
    background: var(--primary);
    border-radius: 50%;
  }

  /* ===== TASK CARDS ===== */
  .task-item {
    display: flex; align-items: center; gap: 12px;
    background: var(--card);
    border-radius: var(--radius-sm);
    padding: 12px 14px;
    box-shadow: var(--shadow-sm);
    border: 1.5px solid var(--border-strong);
    transition: all 0.2s ease;
    animation: taskEnter 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    cursor: grab;
  }
  .task-item:active { cursor: grabbing; }
  .task-item.dragging { opacity: 0.4; transform: scale(0.97); }

  @keyframes taskEnter {
    from { opacity: 0; transform: translateY(-6px) scale(0.98); }
    to { opacity: 1; transform: translateY(0) scale(1); }
  }

  .task-checkbox {
    width: 24px; height: 24px; flex-shrink: 0;
    border: 2.5px solid var(--border-strong);
    border-radius: 7px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
    -webkit-tap-highlight-color: transparent;
    background: var(--card);
  }
  .task-checkbox:active { transform: scale(0.85); }

  .task-item.completed .task-checkbox {
    background: var(--success);
    border-color: var(--success);
    animation: checkPop 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes checkPop {
    0% { transform: scale(1); }
    30% { transform: scale(1.4); }
    60% { transform: scale(0.9); }
    100% { transform: scale(1); }
  }

  .task-checkbox svg {
    width: 12px; height: 12px;
    opacity: 0; transform: scale(0);
    transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
  }
  .task-item.completed .task-checkbox svg {
    opacity: 1; transform: scale(1);
  }

  .task-body { flex: 1; min-width: 0; }

  .task-color-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 6px;
    vertical-align: middle;
    flex-shrink: 0;
  }

  .task-title {
    font-size: 14px; font-weight: 500;
    line-height: 1.35;
    color: var(--text);
    transition: all 0.25s ease;
    word-break: break-word;
  }

  .task-item.completed .task-title {
    text-decoration: line-through;
    text-decoration-thickness: 2px;
    text-decoration-color: var(--success);
    color: var(--text-secondary);
  }

  .task-time {
    font-size: 11px; font-weight: 500;
    color: var(--text-tertiary);
    margin-top: 2px;
    letter-spacing: 0.1px;
  }
  .task-item.completed .task-time { color: var(--success); opacity: 0.8; font-weight: 600; }

  /* Done badge */
  .done-badge {
    display: inline-flex; align-items: center; gap: 3px;
    font-size: 10px; font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--success);
    background: var(--success-soft);
    padding: 3px 8px;
    border-radius: 6px;
    animation: badgePop 0.35s cubic-bezier(0.16, 1, 0.3, 1);
  }
  @keyframes badgePop {
    0% { transform: scale(0); opacity: 0; }
    60% { transform: scale(1.15); }
    100% { transform: scale(1); opacity: 1; }
  }

  .task-meta {
    display: flex; align-items: center; gap: 6px;
    margin-top: 3px;
  }

  .task-tag {
    font-size: 10px; font-weight: 600;
    padding: 2px 7px; border-radius: 6px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    line-height: 1.4;
  }
  .task-tag.office { background: var(--office-soft); color: var(--office-text); }
  .task-tag.remote { background: var(--remote-soft); color: var(--remote-text); }

  .task-actions {
    display: flex; gap: 2px;
    opacity: 0.4;
    transition: opacity 0.15s;
    flex-shrink: 0;
  }
  .task-item:hover .task-actions,
  .task-item:active .task-actions { opacity: 1; }

  .task-action-btn {
    width: 34px; height: 34px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: transparent;
    border-radius: var(--radius-xs);
    cursor: pointer;
    color: var(--text-tertiary);
    transition: all 0.15s ease;
    -webkit-tap-highlight-color: transparent;
  }
  .task-action-btn svg { width: 15px; height: 15px; }
  .task-action-btn:active { background: var(--border); transform: scale(0.9); }
  .task-action-btn.delete:active { background: var(--danger-soft); color: var(--danger); }

  /* Color-coded time block fills */
  .time-content.blocked {
    min-height: 40px;
    border-radius: 0;
    position: relative;
  }
  .time-content.blocked.block-start {
    border-radius: var(--radius-sm) var(--radius-sm) 0 0;
    padding-top: 0;
  }
  .time-content.blocked.block-end {
    border-radius: 0 0 var(--radius-sm) var(--radius-sm);
  }
  .time-content.blocked.block-single {
    border-radius: var(--radius-sm);
  }
  .time-content.blocked.block-start.block-end {
    border-radius: var(--radius-sm);
  }

  /* Task color palette — bold & opaque */
  .time-content.color-indigo { background: #C7D2FE; border-left: 5px solid #4F46E5; }
  .time-content.color-blue { background: #BFDBFE; border-left: 5px solid #2563EB; }
  .time-content.color-emerald { background: #A7F3D0; border-left: 5px solid #059669; }
  .time-content.color-amber { background: #FDE68A; border-left: 5px solid #D97706; }
  .time-content.color-rose { background: #FECDD3; border-left: 5px solid #E11D48; }
  .time-content.color-cyan { background: #A5F3FC; border-left: 5px solid #0891B2; }
  .time-content.color-violet { background: #DDD6FE; border-left: 5px solid #7C3AED; }
  .time-content.color-orange { background: #FED7AA; border-left: 5px solid #EA580C; }

  .time-content.blocked.completed-block {
    opacity: 0.5;
  }

  /* Task card inside colored block */
  .task-item.in-block {
    background: transparent;
    box-shadow: none;
    border: none;
    padding: 8px 10px;
    border-radius: 0;
  }
  .task-item.in-block .task-title {
    font-weight: 600;
    font-size: 14px;
  }
  .task-item.in-block .task-time {
    color: var(--text-secondary);
    opacity: 0.8;
  }
  .task-item.in-block .task-checkbox {
    background: rgba(255,255,255,0.7);
  }
  .task-item.in-block.completed .task-checkbox {
    background: var(--success);
    border-color: var(--success);
  }
  .task-item.in-block.completed .task-title {
    text-decoration: line-through;
    color: var(--text-secondary);
  }
  .task-item.in-block .task-actions { opacity: 0.5; }
  .task-item.in-block:hover .task-actions,
  .task-item.in-block:active .task-actions { opacity: 1; }
  .task-item.in-block .task-action-btn { color: var(--text-secondary); }

  /* Drop zone */
  .drop-zone {
    min-height: 4px; border-radius: var(--radius-xs);
    transition: all 0.2s ease;
  }
  .drop-zone.drag-over {
    min-height: 48px;
    background: var(--primary-soft);
    border: 2px dashed var(--primary);
    border-radius: var(--radius-sm);
  }

  /* ===== FAB ===== */
  .fab {
    position: fixed;
    bottom: 28px; right: 20px;
    width: 56px; height: 56px;
    border-radius: 18px;
    background: var(--primary);
    color: white; border: none;
    box-shadow: var(--shadow-fab);
    cursor: pointer;
    z-index: 200;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
    -webkit-tap-highlight-color: transparent;
  }
  .fab svg { width: 24px; height: 24px; }
  .fab:active { transform: scale(0.9); background: var(--primary-hover); }

  /* ===== MODAL ===== */
  .modal-overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 300;
    display: flex; align-items: flex-end; justify-content: center;
    opacity: 0; pointer-events: none;
    transition: opacity 0.2s ease;
  }
  .modal-overlay.open { opacity: 1; pointer-events: auto; }

  .modal {
    background: var(--card);
    border-radius: 24px 24px 0 0;
    width: 100%; max-width: 480px;
    padding: 12px 24px 28px;
    transform: translateY(100%);
    transition: transform 0.35s cubic-bezier(0.16, 1, 0.3, 1);
    max-height: 85dvh;
    overflow-y: auto;
  }
  .modal-overlay.open .modal { transform: translateY(0); }

  .modal-handle {
    width: 36px; height: 4px;
    background: var(--border-strong);
    border-radius: 2px;
    margin: 4px auto 20px;
  }

  .modal h2 {
    font-size: 18px; font-weight: 700;
    margin-bottom: 20px;
    color: var(--text);
  }

  .form-group { margin-bottom: 16px; }

  .form-group label {
    display: block; font-size: 13px;
    font-weight: 600; color: var(--text-secondary);
    margin-bottom: 6px;
    letter-spacing: 0.1px;
  }

  .form-group input, .form-group select {
    width: 100%; padding: 12px 14px;
    border: 2px solid var(--border-strong);
    border-radius: var(--radius-xs);
    font-size: 15px;
    font-family: inherit;
    background: #FFFFFF;
    color: var(--text);
    transition: all 0.15s ease;
    -webkit-appearance: none;
  }
  .form-group input::placeholder { color: var(--text-tertiary); }
  .form-group input:focus, .form-group select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(99,102,241,0.12);
  }

  .form-row { display: flex; gap: 12px; }
  .form-row .form-group { flex: 1; }

  .modal-actions {
    display: flex; gap: 10px; margin-top: 24px;
  }

  .btn {
    flex: 1; padding: 14px;
    border: none; border-radius: var(--radius-xs);
    font-size: 15px; font-weight: 600;
    font-family: inherit;
    cursor: pointer; text-align: center;
    -webkit-tap-highlight-color: transparent;
    transition: all 0.15s ease;
  }
  .btn-primary {
    background: var(--primary); color: white;
    box-shadow: 0 2px 8px rgba(99,102,241,0.25);
  }
  .btn-primary:active { background: var(--primary-hover); transform: scale(0.98); }
  .btn-secondary { background: var(--border); color: var(--text-secondary); }
  .btn-secondary:active { background: var(--border-strong); }

  /* ===== RECURRING TASKS ===== */
  .recurring-list { list-style: none; }
  .recurring-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 16px;
    background: var(--bg);
    border-radius: var(--radius-sm);
    margin-bottom: 8px;
    border: 1px solid var(--border);
  }
  .recurring-item .info { flex: 1; }
  .recurring-item .info .name { font-size: 14px; font-weight: 600; color: var(--text); }
  .recurring-item .info .meta { font-size: 12px; color: var(--text-tertiary); margin-top: 3px; }

  /* ===== SCROLLBAR ===== */
  ::-webkit-scrollbar { width: 0; }

  /* ===== SAFE AREA ===== */
  @supports (padding-top: env(safe-area-inset-top)) {
    .header { padding-top: calc(16px + env(safe-area-inset-top)); }
    body { padding-bottom: calc(120px + env(safe-area-inset-bottom)); }
    .fab { bottom: calc(28px + env(safe-area-inset-bottom)); }
    .modal { padding-bottom: calc(28px + env(safe-area-inset-bottom)); }
  }

  /* ===== EMPTY STATE ===== */
  .empty-state {
    text-align: center;
    padding: 48px 24px;
    color: var(--text-tertiary);
  }
  .empty-state-icon {
    font-size: 40px;
    margin-bottom: 12px;
    opacity: 0.6;
  }
  .empty-state p {
    font-size: 14px;
    line-height: 1.5;
  }

  /* ===== COLOR PICKER ===== */
  .color-picker {
    display: flex; gap: 8px; flex-wrap: wrap;
    padding: 4px 0;
  }
  .color-swatch {
    width: 38px; height: 38px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: all 0.15s ease;
    -webkit-tap-highlight-color: transparent;
    position: relative;
  }
  .color-swatch:active { transform: scale(0.9); }
  .color-swatch.selected {
    border-color: var(--text);
    box-shadow: 0 0 0 2px var(--card), 0 0 0 4px var(--text);
  }
  .color-swatch.selected::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    width: 10px; height: 10px;
    background: white;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    pointer-events: none;
  }
  .color-swatch[data-color="indigo"] { background: #4F46E5; }
  .color-swatch[data-color="blue"] { background: #2563EB; }
  .color-swatch[data-color="emerald"] { background: #059669; }
  .color-swatch[data-color="amber"] { background: #D97706; }
  .color-swatch[data-color="rose"] { background: #E11D48; }
  .color-swatch[data-color="cyan"] { background: #0891B2; }
  .color-swatch[data-color="violet"] { background: #7C3AED; }
  .color-swatch[data-color="orange"] { background: #EA580C; }

  /* ===== EXPAND BUTTON & SUBTASK PROGRESS ===== */
  .expand-btn {
    width: 28px; height: 28px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: var(--border);
    border-radius: 50%;
    cursor: pointer;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    -webkit-tap-highlight-color: transparent;
    flex-shrink: 0;
  }
  .expand-btn svg { width: 14px; height: 14px; transition: transform 0.25s ease; }
  .expand-btn:active { transform: scale(0.9); background: var(--border-strong); }
  .expand-btn.expanded svg { transform: rotate(180deg); }

  .subtask-progress {
    display: inline-flex; align-items: center; gap: 3px;
    font-size: 10px; font-weight: 700;
    color: var(--primary);
    background: var(--primary-soft);
    padding: 2px 8px;
    border-radius: 10px;
    letter-spacing: 0.2px;
    white-space: nowrap;
  }
  .subtask-progress.all-done {
    color: var(--success);
    background: var(--success-soft);
  }

  /* ===== SUBTASK LIST (collapsible) ===== */
  .subtask-list {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.35s cubic-bezier(0.16, 1, 0.3, 1),
                opacity 0.25s ease,
                padding 0.25s ease;
    opacity: 0;
    padding: 0 0 0 36px;
    margin: 0;
  }
  .subtask-list.open {
    max-height: 600px;
    opacity: 1;
    padding: 8px 0 4px 36px;
  }

  .subtask-item {
    display: flex; align-items: center; gap: 8px;
    padding: 6px 8px;
    border-radius: var(--radius-xs);
    transition: background 0.15s ease;
    animation: subtaskEnter 0.25s cubic-bezier(0.16, 1, 0.3, 1);
  }
  .subtask-item:hover { background: var(--bg); }

  @keyframes subtaskEnter {
    from { opacity: 0; transform: translateY(-4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .subtask-checkbox {
    width: 18px; height: 18px; flex-shrink: 0;
    border: 2px solid var(--border-strong);
    border-radius: 5px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
    background: var(--card);
    -webkit-tap-highlight-color: transparent;
  }
  .subtask-checkbox:active { transform: scale(0.85); }
  .subtask-checkbox svg {
    width: 10px; height: 10px;
    opacity: 0; transform: scale(0);
    transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
  }
  .subtask-item.done .subtask-checkbox {
    background: var(--success);
    border-color: var(--success);
  }
  .subtask-item.done .subtask-checkbox svg {
    opacity: 1; transform: scale(1);
  }

  .subtask-title {
    flex: 1; min-width: 0;
    font-size: 13px; font-weight: 400;
    color: var(--text);
    line-height: 1.3;
    word-break: break-word;
    transition: all 0.2s ease;
  }
  .subtask-item.done .subtask-title {
    text-decoration: line-through;
    text-decoration-thickness: 1.5px;
    text-decoration-color: var(--success);
    color: var(--text-tertiary);
  }

  .subtask-delete {
    width: 22px; height: 22px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: transparent;
    border-radius: 50%;
    cursor: pointer;
    color: var(--text-tertiary);
    opacity: 0;
    transition: all 0.15s ease;
    -webkit-tap-highlight-color: transparent;
    flex-shrink: 0;
  }
  .subtask-delete svg { width: 12px; height: 12px; }
  .subtask-item:hover .subtask-delete { opacity: 0.6; }
  .subtask-delete:hover { opacity: 1 !important; color: var(--danger); background: var(--danger-soft); }

  /* Subtask inline input row */
  .subtask-add-row {
    display: flex; align-items: center; gap: 6px;
    padding: 4px 8px 2px;
    margin-top: 2px;
  }
  .subtask-input {
    flex: 1;
    border: none;
    border-bottom: 1.5px solid var(--border-strong);
    background: transparent;
    padding: 6px 2px;
    font-size: 13px;
    font-family: inherit;
    color: var(--text);
    outline: none;
    transition: border-color 0.15s ease;
  }
  .subtask-input::placeholder { color: var(--text-tertiary); }
  .subtask-input:focus { border-color: var(--primary); }

  .subtask-add-btn {
    width: 26px; height: 26px;
    display: flex; align-items: center; justify-content: center;
    border: none;
    background: var(--primary);
    color: white;
    border-radius: 50%;
    cursor: pointer;
    flex-shrink: 0;
    transition: all 0.15s ease;
    -webkit-tap-highlight-color: transparent;
  }
  .subtask-add-btn svg { width: 14px; height: 14px; }
  .subtask-add-btn:active { transform: scale(0.9); background: var(--primary-hover); }

  /* ===== AUTH SCREEN ===== */
  .auth-screen {
    position: fixed; inset: 0;
    background: var(--bg);
    z-index: 500;
    display: flex; align-items: center; justify-content: center;
    padding: 24px;
  }
  .auth-screen.hidden { display: none; }

  .auth-card {
    background: var(--card);
    border-radius: var(--radius);
    padding: 32px 28px;
    width: 100%; max-width: 380px;
    box-shadow: var(--shadow-lg);
    border: 1.5px solid var(--border);
  }
  .auth-card h1 {
    font-size: 24px; font-weight: 700;
    color: var(--text);
    text-align: center;
    margin-bottom: 4px;
  }
  .auth-card .auth-sub {
    font-size: 14px;
    color: var(--text-tertiary);
    text-align: center;
    margin-bottom: 24px;
  }
  .auth-card .form-group { margin-bottom: 14px; }
  .auth-error {
    font-size: 13px;
    color: var(--danger);
    background: var(--danger-soft);
    padding: 8px 12px;
    border-radius: var(--radius-xs);
    margin-bottom: 14px;
    display: none;
  }
  .auth-error.visible { display: block; }
  .auth-actions { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
  .auth-toggle {
    font-size: 13px;
    color: var(--text-tertiary);
    text-align: center;
    margin-top: 16px;
  }
  .auth-toggle a {
    color: var(--primary);
    font-weight: 600;
    cursor: pointer;
    text-decoration: none;
  }
  .auth-toggle a:hover { text-decoration: underline; }

  /* Logout button in header */
  .logout-btn {
    width: 34px; height: 34px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: none;
    border-radius: 50%; cursor: pointer;
    color: var(--text-tertiary);
    transition: all 0.15s ease;
    -webkit-tap-highlight-color: transparent;
  }
  .logout-btn svg { width: 18px; height: 18px; }
  .logout-btn:active { background: var(--danger-soft); color: var(--danger); }
</style>
</head>
<body>

<!-- Auth Screen -->
<div class="auth-screen" id="authScreen">
  <div class="auth-card">
    <h1>Daily Planner</h1>
    <p class="auth-sub">Sign in to sync across devices</p>
    <div class="auth-error" id="authError"></div>
    <div class="form-group">
      <label>Email</label>
      <input type="email" id="authEmail" placeholder="you@example.com" autocomplete="email">
    </div>
    <div class="form-group">
      <label>Password</label>
      <input type="password" id="authPassword" placeholder="Min 6 characters" autocomplete="current-password">
    </div>
    <div class="auth-actions">
      <button class="btn btn-primary" id="authLoginBtn" onclick="doLogin()">Sign In</button>
      <button class="btn btn-secondary" id="authSignupBtn" onclick="doSignup()">Create Account</button>
    </div>
    <p class="auth-toggle">
      <span id="authToggleText"></span>
    </p>
  </div>
</div>

<header class="header">
  <div class="header-top">
    <button class="nav-btn" id="prevDay" aria-label="Previous day">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
    </button>
    <div class="header-center">
      <div class="date-display">
        <span class="date-weekday" id="dateWeekday"></span>
        <span class="date-main" id="dateMain"></span>
      </div>
      <div class="header-meta">
        <span id="dayBadge"></span>
        <button class="today-btn" id="todayBtn" onclick="goToday()">Today</button>
      </div>
    </div>
    <button class="nav-btn" id="nextDay" aria-label="Next day">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
    </button>
    <button class="logout-btn" onclick="doLogout()" title="Sign out">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
    </button>
  </div>
</header>

<main class="timeline swipe-area" id="timeline"></main>

<button class="fab" id="fabAdd" aria-label="Add task">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
</button>

<!-- Add/Edit Task Modal -->
<div class="modal-overlay" id="taskModal">
  <div class="modal">
    <div class="modal-handle"></div>
    <h2 id="modalTitle">New Task</h2>
    <div class="form-group">
      <label>What needs to be done?</label>
      <input type="text" id="taskNameInput" placeholder="e.g. Team standup, Review PRs..." autocomplete="off">
    </div>
    <div class="form-row">
      <div class="form-group">
        <label>Start</label>
        <select id="taskHourSelect"></select>
      </div>
      <div class="form-group">
        <label>End</label>
        <select id="taskEndSelect"></select>
      </div>
    </div>
    <div class="form-group">
      <label>Day Type</label>
      <select id="taskTypeSelect">
        <option value="any">Any Day</option>
        <option value="office">Office Only</option>
        <option value="remote">Remote Only</option>
      </select>
    </div>
    <div class="form-group">
      <label>Color</label>
      <div class="color-picker" id="colorPicker">
        <div class="color-swatch selected" data-color="indigo" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="blue" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="emerald" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="amber" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="rose" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="cyan" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="violet" onclick="pickColor(this)"></div>
        <div class="color-swatch" data-color="orange" onclick="pickColor(this)"></div>
      </div>
    </div>
    <div class="form-group">
      <label>Repeat</label>
      <select id="taskRecurrence">
        <option value="none">Just this day</option>
        <option value="daily">Every day</option>
        <option value="weekdays">Weekdays</option>
        <option value="office">Office days</option>
        <option value="remote">Remote days</option>
      </select>
    </div>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
      <button class="btn btn-primary" id="saveTaskBtn" onclick="saveTask()">Add Task</button>
    </div>
  </div>
</div>

<!-- Recurring Tasks Modal -->
<div class="modal-overlay" id="recurringModal">
  <div class="modal">
    <div class="modal-handle"></div>
    <h2>Recurring Tasks</h2>
    <ul class="recurring-list" id="recurringList"></ul>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closeRecurringModal()">Close</button>
    </div>
  </div>
</div>

<script>
// ======== STATE ========
const START_HOUR = 6;
const END_HOUR = 22;
const OFFICE_START = new Date(2026, 1, 10); // Feb 10, 2026

let currentDate = new Date();
currentDate.setHours(0,0,0,0);
let editingTaskId = null;
let expandedTasks = new Set();

// ======== SUPABASE ========
const SUPABASE_URL = 'https://ertmoasccqnvbximpmdg.supabase.co';
const SUPABASE_KEY = 'sb_publishable_BpjTtr_XFGMFiTxiinCbTQ_qJSXO3MO';
const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
let currentUserId = null;

// ======== AUTH ========
function showAuth() {
  document.getElementById('authScreen').classList.remove('hidden');
}
function hideAuth() {
  document.getElementById('authScreen').classList.add('hidden');
}

function showAuthError(msg) {
  const el = document.getElementById('authError');
  el.textContent = msg;
  el.classList.add('visible');
}
function clearAuthError() {
  document.getElementById('authError').classList.remove('visible');
}

async function doLogin() {
  clearAuthError();
  const email = document.getElementById('authEmail').value.trim();
  const password = document.getElementById('authPassword').value;
  if (!email || !password) { showAuthError('Please enter email and password'); return; }

  document.getElementById('authLoginBtn').textContent = 'Signing in...';
  const { data, error } = await sb.auth.signInWithPassword({ email, password });
  document.getElementById('authLoginBtn').textContent = 'Sign In';

  if (error) { showAuthError(error.message); return; }
  currentUserId = data.user.id;
  hideAuth();
  await syncFromCloud();
  render();
}

async function doSignup() {
  clearAuthError();
  const email = document.getElementById('authEmail').value.trim();
  const password = document.getElementById('authPassword').value;
  if (!email || !password) { showAuthError('Please enter email and password'); return; }
  if (password.length < 6) { showAuthError('Password must be at least 6 characters'); return; }

  document.getElementById('authSignupBtn').textContent = 'Creating account...';
  const { data, error } = await sb.auth.signUp({ email, password });
  document.getElementById('authSignupBtn').textContent = 'Create Account';

  if (error) { showAuthError(error.message); return; }
  if (data.session) {
    // Auto-confirmed — logged in directly
    currentUserId = data.user.id;
    hideAuth();
    await migrateLocalData();
    render();
  } else if (data.user) {
    // Email confirmation required
    showAuthError('Account created! Check your email to confirm, then sign in.');
  } else {
    showAuthError('Something went wrong. Please try again.');
  }
}

async function doLogout() {
  await sb.auth.signOut();
  currentUserId = null;
  showAuth();
}

async function migrateLocalData() {
  if (!currentUserId) return;
  const tasks = loadData('planner_tasks', []);
  const recurring = loadData('planner_recurring', []);
  if (tasks.length > 0) {
    await sb.from('planner_store').upsert({ key: 'planner_tasks', data: tasks, user_id: currentUserId, updated_at: new Date().toISOString() });
  }
  if (recurring.length > 0) {
    await sb.from('planner_store').upsert({ key: 'planner_recurring', data: recurring, user_id: currentUserId, updated_at: new Date().toISOString() });
  }
}

async function checkAuth() {
  const { data: { session } } = await sb.auth.getSession();
  if (session && session.user) {
    currentUserId = session.user.id;
    hideAuth();
    await syncFromCloud();
    render();
  } else {
    showAuth();
    // Still render with localStorage data for offline use
    render();
  }
}

// Enter key on auth inputs
document.getElementById('authEmail').addEventListener('keydown', e => { if (e.key === 'Enter') document.getElementById('authPassword').focus(); });
document.getElementById('authPassword').addEventListener('keydown', e => { if (e.key === 'Enter') doLogin(); });

// ======== STORAGE (localStorage + cloud sync) ========
function loadData(key, fallback) {
  try { return JSON.parse(localStorage.getItem(key)) || fallback; }
  catch { return fallback; }
}
function saveData(key, val) {
  localStorage.setItem(key, JSON.stringify(val));
  if (!currentUserId) return; // Don't sync if not logged in
  // Fire-and-forget cloud sync
  sb.from('planner_store').upsert({ key, data: val, user_id: currentUserId, updated_at: new Date().toISOString() }).then();
}

async function syncFromCloud() {
  if (!currentUserId) return;
  try {
    const { data, error } = await sb.from('planner_store').select('*');
    if (error) throw error;
    if (data && data.length > 0) {
      data.forEach(row => {
        localStorage.setItem(row.key, JSON.stringify(row.data));
      });
    } else {
      // First login: push existing localStorage data to cloud
      await migrateLocalData();
    }
  } catch (e) {
    console.warn('Cloud sync failed, using local data:', e.message);
  }
}

function getTasks() { return loadData('planner_tasks', []); }
function saveTasks(tasks) { saveData('planner_tasks', tasks); }
function getRecurring() { return loadData('planner_recurring', []); }
function saveRecurring(recs) { saveData('planner_recurring', recs); }

// ======== OFFICE CADENCE ========
function isOfficeDay(date) {
  const day = date.getDay();
  if (day !== 2 && day !== 3) return false;
  const startWeekMonday = new Date(OFFICE_START);
  startWeekMonday.setDate(startWeekMonday.getDate() - startWeekMonday.getDay() + 1);
  const dateWeekMonday = new Date(date);
  dateWeekMonday.setDate(dateWeekMonday.getDate() - dateWeekMonday.getDay() + 1);
  const weekDiff = Math.round((dateWeekMonday - startWeekMonday) / (7 * 86400000));
  return weekDiff % 2 === 0;
}

function getDayType(date) {
  const day = date.getDay();
  if (day === 0 || day === 6) return 'weekend';
  if (isOfficeDay(date)) return 'office';
  return 'remote';
}

// ======== DATE HELPERS ========
function dateKey(d) {
  return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
}
function isToday(d) {
  const t = new Date(); t.setHours(0,0,0,0);
  return d.getTime() === t.getTime();
}
function formatSlot(slot) {
  const h = Math.floor(slot);
  const m = slot % 1 === 0.5 ? '30' : '00';
  const hour = h % 12 || 12;
  const ampm = h < 12 ? 'AM' : 'PM';
  return hour + ':' + m + ' ' + ampm;
}
function formatHour(h) { return formatSlot(h); }
function uid() { return Date.now().toString(36) + Math.random().toString(36).slice(2,7); }

// ======== GET TASKS FOR DATE ========
function getTasksForDate(date) {
  const key = dateKey(date);
  const dayType = getDayType(date);
  const allTasks = getTasks().filter(t => t.date === key);
  const recurring = getRecurring();
  const dow = date.getDay();

  recurring.forEach(r => {
    if (allTasks.some(t => t.recurringId === r.id)) return;
    let shouldShow = false;
    if (r.recurrence === 'daily') shouldShow = true;
    else if (r.recurrence === 'weekdays' && dow >= 1 && dow <= 5) shouldShow = true;
    else if (r.recurrence === 'office' && dayType === 'office') shouldShow = true;
    else if (r.recurrence === 'remote' && dayType === 'remote') shouldShow = true;
    if (r.type === 'office' && dayType !== 'office') shouldShow = false;
    if (r.type === 'remote' && dayType !== 'remote') shouldShow = false;

    if (shouldShow) {
      const task = { id: uid(), title: r.title, hour: r.hour, endHour: r.endHour || r.hour + 0.5, date: key, completed: false, recurringId: r.id, type: r.type, color: r.color || 'indigo' };
      allTasks.push(task);
      const tasks = getTasks();
      tasks.push(task);
      saveTasks(tasks);
    }
  });
  return allTasks.filter(t => !t.dismissed);
}

// ======== RENDER ========
function render() {
  const dayType = getDayType(currentDate);
  const today = isToday(currentDate);
  const now = new Date();
  const nowHour = now.getHours();
  const nowMin = now.getMinutes();
  const currentSlot = nowHour + (nowMin >= 30 ? 0.5 : 0);

  // Header
  document.getElementById('dateWeekday').textContent = currentDate.toLocaleDateString('en-US', { weekday: 'long' });
  document.getElementById('dateMain').textContent = currentDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
  document.getElementById('todayBtn').classList.toggle('visible', !today);

  const badgeEl = document.getElementById('dayBadge');
  if (dayType === 'office') {
    badgeEl.innerHTML = '<span class="day-badge office">In Office</span>';
  } else if (dayType === 'remote') {
    badgeEl.innerHTML = '<span class="day-badge remote">Remote</span>';
  } else {
    badgeEl.innerHTML = '<span class="day-badge weekend">Weekend</span>';
  }

  // Tasks
  const tasks = getTasksForDate(currentDate);
  const timeline = document.getElementById('timeline');
  let html = '';

  for (let slot = START_HOUR; slot <= END_HOUR; slot += 0.5) {
    // Tasks that START at this slot
    const startingTasks = tasks.filter(t => t.hour === slot);
    // Tasks that COVER this slot (started at or before, end after)
    const coveringTasks = tasks.filter(t => {
      const end = t.endHour != null ? t.endHour : t.hour + 0.5;
      return t.hour <= slot && end > slot;
    });
    const isCurrent = today && slot === currentSlot;
    const hasContent = coveringTasks.length > 0;
    const isOnHour = slot % 1 === 0;

    // Determine block classes for the first covering task (primary block color)
    let blockClasses = '';
    if (coveringTasks.length > 0) {
      const primary = coveringTasks[0];
      const end = primary.endHour != null ? primary.endHour : primary.hour + 0.5;
      const isStart = primary.hour === slot;
      const isEnd = (slot + 0.5) >= end;
      const color = primary.color || 'indigo';
      blockClasses = `blocked color-${color}`;
      if (isStart && isEnd) blockClasses += ' block-single';
      else if (isStart) blockClasses += ' block-start';
      else if (isEnd) blockClasses += ' block-end';
      if (primary.completed) blockClasses += ' completed-block';
    }

    html += `<div class="time-block ${isCurrent ? 'current-slot' : ''} ${!hasContent ? 'empty' : ''} ${isOnHour ? 'on-hour' : 'half-hour'}" data-hour="${slot}">`;
    html += `<div class="time-gutter"><div class="time-label">${formatSlot(slot)}</div></div>`;
    html += `<div class="time-content ${blockClasses}" data-hour="${slot}" ondragover="onDragOver(event)" ondrop="onDrop(event, ${slot})" ondragleave="onDragLeave(event)">`;

    // Only render task card at its start slot
    startingTasks.forEach(task => { html += renderTask(task, true); });

    if (!hasContent) {
      html += `<div class="drop-zone" data-hour="${slot}" ondragover="onDragOver(event)" ondrop="onDrop(event, ${slot})" ondragleave="onDragLeave(event)"></div>`;
    }

    html += `</div></div>`;
  }

  timeline.innerHTML = html;

  if (today) {
    const cur = document.querySelector('.current-slot');
    if (cur) setTimeout(() => cur.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100);
  }
}

function renderTask(task, inBlock) {
  const tagHtml = task.type === 'office'
    ? '<span class="task-tag office">Office</span>'
    : task.type === 'remote'
    ? '<span class="task-tag remote">Remote</span>'
    : '';

  const endHour = task.endHour != null ? task.endHour : task.hour + 0.5;
  const timeStr = formatSlot(task.hour) + ' – ' + formatSlot(endHour);

  // Subtask progress
  const subtasks = task.subtasks || [];
  const doneCount = subtasks.filter(s => s.done).length;
  const totalCount = subtasks.length;
  const isExpanded = expandedTasks.has(task.id);
  const progressHtml = totalCount > 0
    ? `<span class="subtask-progress ${doneCount === totalCount ? 'all-done' : ''}">${doneCount}/${totalCount}</span>`
    : '';

  // Subtask list HTML
  let subtaskListHtml = '';
  subtaskListHtml += `<div class="subtask-list ${isExpanded ? 'open' : ''}" id="subtasks-${task.id}">`;
  subtasks.forEach(st => {
    subtaskListHtml += `
      <div class="subtask-item ${st.done ? 'done' : ''}" data-subtask-id="${st.id}">
        <div class="subtask-checkbox" onclick="toggleSubtask('${task.id}','${st.id}')">
          <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>
        </div>
        <span class="subtask-title">${escHtml(st.title)}</span>
        <button class="subtask-delete" onclick="deleteSubtask('${task.id}','${st.id}')" aria-label="Delete subtask">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
      </div>`;
  });
  subtaskListHtml += `
    <div class="subtask-add-row">
      <input type="text" class="subtask-input" id="subtask-input-${task.id}" placeholder="Add item..." onkeydown="if(event.key==='Enter')addSubtask('${task.id}')" autocomplete="off">
      <button class="subtask-add-btn" onclick="addSubtask('${task.id}')" aria-label="Add subtask">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
      </button>
    </div>
  </div>`;

  return `
    <div class="task-item ${task.completed ? 'completed' : ''} ${inBlock ? 'in-block' : ''}"
         draggable="true" data-id="${task.id}"
         ondragstart="onDragStart(event, '${task.id}')"
         ondragend="onDragEnd(event)">
      <div class="task-checkbox" onclick="toggleTask('${task.id}')">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </div>
      <div class="task-body">
        <div class="task-title"><span class="task-color-dot" style="background:${COLOR_HEX[task.color] || COLOR_HEX.indigo}"></span>${escHtml(task.title)}</div>
        <div class="task-time">${task.completed ? '&#10003; ' : ''}${timeStr}</div>
        <div class="task-meta">
          ${task.completed ? '<span class="done-badge">Done</span>' : ''}
          ${progressHtml}
          ${tagHtml}
        </div>
      </div>
      <button class="expand-btn ${isExpanded ? 'expanded' : ''}" onclick="toggleExpand('${task.id}')" aria-label="Expand subtasks">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
      </button>
      <div class="task-actions">
        <button class="task-action-btn" onclick="editTask('${task.id}')" aria-label="Edit">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
        </button>
        <button class="task-action-btn delete" onclick="deleteTask('${task.id}')" aria-label="Delete">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
      </div>
    </div>
    ${subtaskListHtml}`;
}

function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ======== COLOR PICKER ========
const COLOR_HEX = { indigo:'#4F46E5', blue:'#2563EB', emerald:'#059669', amber:'#D97706', rose:'#E11D48', cyan:'#0891B2', violet:'#7C3AED', orange:'#EA580C' };
let selectedColor = 'indigo';

function pickColor(el) {
  document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
  el.classList.add('selected');
  selectedColor = el.dataset.color;
}

function setPickerColor(color) {
  selectedColor = color || 'indigo';
  document.querySelectorAll('.color-swatch').forEach(s => {
    s.classList.toggle('selected', s.dataset.color === selectedColor);
  });
}

// ======== TASK ACTIONS ========
function toggleTask(id) {
  const tasks = getTasks();
  const t = tasks.find(t => t.id === id);
  if (!t) return;
  const wasCompleted = t.completed;
  t.completed = !t.completed;
  // Mark all subtasks to match parent state
  if (t.subtasks && t.subtasks.length > 0) {
    t.subtasks.forEach(s => { s.done = t.completed; });
  }
  saveTasks(tasks);
  render();
  // Celebrate completion
  if (!wasCompleted && t.completed) {
    const el = document.querySelector(`[data-id="${id}"] .task-checkbox`);
    if (el) spawnConfetti(el);
  }
}

function spawnConfetti(anchor) {
  const rect = anchor.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const colors = ['#10B981','#6366F1','#F59E0B','#F43F5E','#3B82F6','#8B5CF6'];
  for (let i = 0; i < 12; i++) {
    const dot = document.createElement('div');
    const angle = (Math.PI * 2 * i) / 12;
    const dist = 30 + Math.random() * 40;
    const size = 5 + Math.random() * 4;
    Object.assign(dot.style, {
      position: 'fixed', left: cx + 'px', top: cy + 'px',
      width: size + 'px', height: size + 'px',
      borderRadius: Math.random() > 0.5 ? '50%' : '2px',
      background: colors[Math.floor(Math.random() * colors.length)],
      pointerEvents: 'none', zIndex: '9999',
      transition: 'all 0.6s cubic-bezier(0.16, 1, 0.3, 1)',
      opacity: '1',
    });
    document.body.appendChild(dot);
    requestAnimationFrame(() => {
      dot.style.transform = `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist - 20}px) scale(0)`;
      dot.style.opacity = '0';
    });
    setTimeout(() => dot.remove(), 700);
  }
}

function deleteTask(id) {
  expandedTasks.delete(id);
  const tasks = getTasks();
  const task = tasks.find(t => t.id === id);
  if (task && task.recurringId) {
    // Mark as dismissed so recurring doesn't recreate it
    task.dismissed = true;
    saveTasks(tasks);
  } else {
    saveTasks(tasks.filter(t => t.id !== id));
  }
  render();
}

// ======== SUBTASK FUNCTIONS ========
function toggleExpand(taskId) {
  if (expandedTasks.has(taskId)) {
    expandedTasks.delete(taskId);
    const list = document.getElementById('subtasks-' + taskId);
    const btn = document.querySelector(`[data-id="${taskId}"]`).parentElement.querySelector('.expand-btn') ||
                document.querySelector(`[data-id="${taskId}"] .expand-btn`);
    if (list) list.classList.remove('open');
    if (btn) btn.classList.remove('expanded');
  } else {
    expandedTasks.add(taskId);
    const list = document.getElementById('subtasks-' + taskId);
    const btn = document.querySelector(`[data-id="${taskId}"] .expand-btn`);
    if (list) list.classList.add('open');
    if (btn) btn.classList.add('expanded');
    // Focus the input after animation
    setTimeout(() => {
      const inp = document.getElementById('subtask-input-' + taskId);
      if (inp) inp.focus();
    }, 200);
  }
}

function addSubtask(taskId) {
  const input = document.getElementById('subtask-input-' + taskId);
  if (!input) return;
  const title = input.value.trim();
  if (!title) return;
  const tasks = getTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) return;
  if (!task.subtasks) task.subtasks = [];
  task.subtasks.push({ id: uid(), title: title, done: false });
  // If parent was completed, uncomplete it since we added new work
  if (task.completed) task.completed = false;
  saveTasks(tasks);
  expandedTasks.add(taskId);
  render();
  // Re-focus input for quick adding
  setTimeout(() => {
    const inp = document.getElementById('subtask-input-' + taskId);
    if (inp) inp.focus();
  }, 50);
}

function toggleSubtask(taskId, subtaskId) {
  const tasks = getTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task || !task.subtasks) return;
  const st = task.subtasks.find(s => s.id === subtaskId);
  if (!st) return;
  const wasDone = st.done;
  st.done = !st.done;

  // Check if all subtasks are done → auto-complete parent
  const allDone = task.subtasks.length > 0 && task.subtasks.every(s => s.done);
  const wasParentCompleted = task.completed;
  if (allDone) {
    task.completed = true;
  } else if (task.completed && !st.done) {
    // Unchecking a subtask should uncomplete parent
    task.completed = false;
  }

  saveTasks(tasks);
  render();

  // Mini confetti for subtask check
  if (!wasDone && st.done) {
    const el = document.querySelector(`[data-subtask-id="${subtaskId}"] .subtask-checkbox`);
    if (el) spawnMiniConfetti(el);
  }
  // Full confetti if all subtasks done and parent auto-completed
  if (allDone && !wasParentCompleted) {
    setTimeout(() => {
      const parentEl = document.querySelector(`[data-id="${taskId}"] .task-checkbox`);
      if (parentEl) spawnConfetti(parentEl);
    }, 300);
  }
}

function spawnMiniConfetti(anchor) {
  const rect = anchor.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const colors = ['#10B981','#6366F1','#F59E0B','#3B82F6'];
  for (let i = 0; i < 6; i++) {
    const dot = document.createElement('div');
    const angle = (Math.PI * 2 * i) / 6;
    const dist = 15 + Math.random() * 20;
    const size = 3 + Math.random() * 3;
    Object.assign(dot.style, {
      position: 'fixed', left: cx + 'px', top: cy + 'px',
      width: size + 'px', height: size + 'px',
      borderRadius: '50%',
      background: colors[Math.floor(Math.random() * colors.length)],
      pointerEvents: 'none', zIndex: '9999',
      transition: 'all 0.45s cubic-bezier(0.16, 1, 0.3, 1)',
      opacity: '1',
    });
    document.body.appendChild(dot);
    requestAnimationFrame(() => {
      dot.style.transform = `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist - 10}px) scale(0)`;
      dot.style.opacity = '0';
    });
    setTimeout(() => dot.remove(), 500);
  }
}

function deleteSubtask(taskId, subtaskId) {
  const tasks = getTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task || !task.subtasks) return;
  task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
  // Recheck auto-complete: if all remaining are done (and there are some), complete parent
  if (task.subtasks.length > 0 && task.subtasks.every(s => s.done)) {
    task.completed = true;
  } else if (task.subtasks.length === 0) {
    // No subtasks left — don't change parent completion state
  }
  saveTasks(tasks);
  render();
}

function editTask(id) {
  const task = getTasks().find(t => t.id === id);
  if (!task) return;
  editingTaskId = id;
  document.getElementById('modalTitle').textContent = 'Edit Task';
  document.getElementById('saveTaskBtn').textContent = 'Save';
  document.getElementById('taskNameInput').value = task.title;
  document.getElementById('taskHourSelect').value = String(task.hour);
  const endVal = task.endHour != null ? task.endHour : task.hour + 0.5;
  document.getElementById('taskEndSelect').value = String(endVal);
  document.getElementById('taskTypeSelect').value = task.type || 'any';
  setPickerColor(task.color);
  document.getElementById('taskRecurrence').value = 'none';
  document.getElementById('taskRecurrence').parentElement.style.display = 'none';
  openModal();
}

// ======== MODAL ========
function openModal() {
  document.getElementById('taskModal').classList.add('open');
  setTimeout(() => document.getElementById('taskNameInput').focus(), 300);
}

function closeModal() {
  document.getElementById('taskModal').classList.remove('open');
  editingTaskId = null;
  document.getElementById('taskNameInput').value = '';
  document.getElementById('modalTitle').textContent = 'New Task';
  document.getElementById('saveTaskBtn').textContent = 'Add Task';
  document.getElementById('taskRecurrence').parentElement.style.display = '';
  // Reset start/end to defaults
  const s = (nowH >= START_HOUR && nowH <= END_HOUR) ? nowH + (nowM >= 30 ? 0.5 : 0) : 9;
  document.getElementById('taskHourSelect').value = String(s);
  document.getElementById('taskEndSelect').value = String(s + 0.5);
  setPickerColor('indigo');
}

function saveTask() {
  const name = document.getElementById('taskNameInput').value.trim();
  if (!name) return;
  const hour = parseFloat(document.getElementById('taskHourSelect').value);
  let endHour = parseFloat(document.getElementById('taskEndSelect').value);
  if (endHour <= hour) endHour = hour + 0.5; // end must be after start
  const type = document.getElementById('taskTypeSelect').value;
  const recurrence = document.getElementById('taskRecurrence').value;

  const color = selectedColor;

  if (editingTaskId) {
    const tasks = getTasks();
    const t = tasks.find(t => t.id === editingTaskId);
    if (t) { t.title = name; t.hour = hour; t.endHour = endHour; t.type = type; t.color = color; saveTasks(tasks); }
  } else if (recurrence !== 'none') {
    const recs = getRecurring();
    recs.push({ id: uid(), title: name, hour, endHour, type, color, recurrence });
    saveRecurring(recs);
  } else {
    const tasks = getTasks();
    tasks.push({ id: uid(), title: name, hour, endHour, date: dateKey(currentDate), completed: false, type, color });
    saveTasks(tasks);
  }
  closeModal();
  render();
}

// ======== RECURRING MODAL ========
function openRecurringModal() {
  const recs = getRecurring();
  const list = document.getElementById('recurringList');
  if (recs.length === 0) {
    list.innerHTML = '<li style="text-align:center;padding:24px;color:var(--text-tertiary);font-size:14px">No recurring tasks yet</li>';
  } else {
    list.innerHTML = recs.map(r => `
      <li class="recurring-item">
        <div class="info">
          <div class="name">${escHtml(r.title)}</div>
          <div class="meta">${formatSlot(r.hour)} – ${formatSlot(r.endHour || r.hour + 0.5)} &middot; ${r.recurrence} &middot; ${r.type === 'any' ? 'All days' : r.type}</div>
        </div>
        <button class="task-action-btn delete" onclick="deleteRecurring('${r.id}')" aria-label="Delete">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
      </li>`).join('');
  }
  document.getElementById('recurringModal').classList.add('open');
}

function closeRecurringModal() {
  document.getElementById('recurringModal').classList.remove('open');
}

function deleteRecurring(id) {
  saveRecurring(getRecurring().filter(r => r.id !== id));
  saveTasks(getTasks().filter(t => t.recurringId !== id));
  openRecurringModal();
  render();
}

// ======== DRAG & DROP ========
let draggedTaskId = null;

function onDragStart(e, id) {
  draggedTaskId = id;
  e.target.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
}
function onDragEnd(e) {
  e.target.classList.remove('dragging');
  document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
}
function onDragOver(e) {
  e.preventDefault();
  e.currentTarget.classList.add('drag-over');
}
function onDragLeave(e) {
  e.currentTarget.classList.remove('drag-over');
}
function onDrop(e, hour) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over');
  if (!draggedTaskId) return;
  const tasks = getTasks();
  const t = tasks.find(t => t.id === draggedTaskId);
  if (t) {
    const duration = (t.endHour || t.hour + 0.5) - t.hour;
    t.hour = hour;
    t.endHour = hour + duration;
    saveTasks(tasks);
  }
  draggedTaskId = null;
  render();
}

// ======== NAVIGATION ========
function changeDay(offset) {
  currentDate.setDate(currentDate.getDate() + offset);
  render();
}

function goToday() {
  currentDate = new Date();
  currentDate.setHours(0,0,0,0);
  render();
}

// Touch swipe
let touchStartX = 0, touchStartY = 0;
document.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}, { passive: true });
document.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > 80 && Math.abs(dx) > Math.abs(dy) * 1.5) {
    changeDay(dx < 0 ? 1 : -1);
  }
}, { passive: true });

// Button nav
document.getElementById('prevDay').addEventListener('click', () => changeDay(-1));
document.getElementById('nextDay').addEventListener('click', () => changeDay(1));

// FAB
document.getElementById('fabAdd').addEventListener('click', () => {
  editingTaskId = null;
  document.getElementById('taskRecurrence').parentElement.style.display = '';
  openModal();
});

// Close modals on overlay click
document.getElementById('taskModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeModal(); });
document.getElementById('recurringModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeRecurringModal(); });

// Enter key
document.getElementById('taskNameInput').addEventListener('keydown', e => { if (e.key === 'Enter') saveTask(); });

// Populate start & end time selects
const hourSelect = document.getElementById('taskHourSelect');
const endSelect = document.getElementById('taskEndSelect');
const nowH = new Date().getHours();
const nowM = new Date().getMinutes();
const defaultStart = (nowH >= START_HOUR && nowH <= END_HOUR) ? nowH + (nowM >= 30 ? 0.5 : 0) : 9;
const defaultEnd = defaultStart + 0.5;

for (let slot = START_HOUR; slot <= END_HOUR + 0.5; slot += 0.5) {
  // Start select: 6:00 AM to 10:00 PM
  if (slot <= END_HOUR) {
    const opt = document.createElement('option');
    opt.value = slot;
    opt.textContent = formatSlot(slot);
    if (slot === defaultStart) opt.selected = true;
    hourSelect.appendChild(opt);
  }
  // End select: 6:30 AM to 10:30 PM (always after earliest start)
  if (slot >= START_HOUR + 0.5) {
    const opt = document.createElement('option');
    opt.value = slot;
    opt.textContent = formatSlot(slot);
    if (slot === defaultEnd) opt.selected = true;
    endSelect.appendChild(opt);
  }
}

// When start changes, bump end if it's not after start
hourSelect.addEventListener('change', () => {
  const startVal = parseFloat(hourSelect.value);
  const endVal = parseFloat(endSelect.value);
  if (endVal <= startVal) {
    endSelect.value = String(Math.min(startVal + 0.5, END_HOUR + 0.5));
  }
});

// ======== INIT ========
checkAuth();
setInterval(() => { if (isToday(currentDate)) render(); }, 60000);
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
